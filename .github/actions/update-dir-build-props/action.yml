name: 'Update Directory.Build.props'
description: 'Update Directory.Build.props for .NET projects'
runs:
  using: "composite"
  steps:
    - name: Ensure Directory.Build.props exists
      shell: pwsh
      run: |
    

        #$propsPath = "Directory.Build.props"
        $propsPath = [System.IO.Path]::GetFullPath("Directory.Build.props")

        function New-PropsXml{
            $doc = New-Object System.Xml.XmlDocument

            # XML declaration
            $xmlDecl = $doc.CreateXmlDeclaration('1.0','utf-8',$null)
            $doc.AppendChild($xmlDecl) | Out-Null

            # <Project Sdk="Microsoft.NET.Sdk">
            $project = $doc.CreateElement('Project')
            # NOTE: Directory.Build.props typically doesn't need Sdk attr, but it's harmless if present.
            # If you prefer no Sdk attr, comment the next line.
            # $project.SetAttribute('Sdk','Microsoft.NET.Sdk') 
            $doc.AppendChild($project) | Out-Null

            # <PropertyGroup>
            $pg = $doc.CreateElement('PropertyGroup')
            $project.AppendChild($pg) | Out-Null

            return $doc
        }

        [xml]$xml = $null
        if(Test-Path $propsPath) {
            try {
                $xml = [xml](Get-Content $propsPath)
            }catch{
                Write-Warning "Existing $propsPath was not valid XML. Recreating."
                $xml = New-PropsXml
            }
            #Write-Error "Directory.Build.props not found at path: $propsPath"
            #exit 1
        }else{
            Write-Warning "Creating new $propsPath"
            $xml = New-PropsXml
        }

        # Ensure <Project> root exists
        if (-not $xml.Project) {
            $project = $xml.CreateElement('Project')
            $null = $xml.AppendChild($project)
        } else {
            $project = $xml.Project
        }

        # Ensure there is at least one <PropertyGroup>
        $pg = $project.PropertyGroup
        if (-not $pg) {
            $pg = $xml.CreateElement('PropertyGroup')
            $null = $project.AppendChild($pg)
        }

        # Helper: set or create a property in the first PropertyGroup
        function Set-XmlProp([string]$name, [string]$value) {
            if ([string]::IsNullOrWhiteSpace($value)) { return }
            $node = $pg.SelectSingleNode($name)
            if (-not $node) {
            $node = $xml.CreateElement($name)
            $null = $pg.AppendChild($node)
            }
            $node.InnerText = $value
        }

        # Pull values from GitVersion step outputs
        $SemVer               = '${{ inputs.version }}'
        $AssemblySemVer       = '${{ inputs.assemblyVersion }}'
        $FileSemVer           = '${{ inputs.fileVersion }}'  # good for FileVersion
        $InformationalVersion = '${{ inputs.infoVersion }}'
        $CompanyName          = '${{ inputs.company }}'
        $CopyrightText        = '${{ inputs.copyright }}'
        if($CopyrightText) {
            $year = (Get-Date).Year
            $CopyrightText = $CopyrightText -replace '\{year\}', $year
        }

        # Map to MSBuild properties
        Set-XmlProp 'Version'              $SemVer
        Set-XmlProp 'AssemblyVersion'      $AssemblySemVer
        Set-XmlProp 'FileVersion'          $FileSemVer
        Set-XmlProp 'InformationalVersion' $InformationalVersion
        if($CompanyName) {
            Set-XmlProp 'Company'           $CompanyName
        }
        if($CopyrightText) {
            Set-XmlProp 'Copyright'         $CopyrightText
        }
        # Save with indentation and UTF-8
        $settings = New-Object System.Xml.XmlWriterSettings
        $settings.Indent = $true
        $settings.IndentChars = "  "
        $settings.NewLineOnAttributes = $false
        $settings.Encoding = New-Object System.Text.UTF8Encoding($false) # no BOM; change to ($true) for BOM

        $writer = [System.Xml.XmlWriter]::Create((Resolve-Path $propsPath), $settings)
        $xml.Save($writer)
        $writer.Flush()
        $writer.Dispose()

        Write-Warning "Updated $propsPath with version info from GitVersion."
        Write-Warning "$($xml.OuterXml)"

    - name: Neutralize AssemblyInfo version attributes
      if: ${{ inputs.neutralizeAssemblyInfo }} == 'true'
      shell: pwsh
      run: |
        $version = '${{ inputs.assemblyVersion }}'
        $fileVersion = '${{ inputs.fileVersion }}'
        $infoVersion = '${{ inputs.infoVersion }}'

        $rootPath = [System.IO.Path]::GetFullPath("./")
        Write-Host "Search Root  = $rootPath"
        Write-Host "Version      = $version"
        Write-Host "File Version = $fileVersion"
        Write-Host "Info Version = $infoVersion"
       
        if($version -match "^\d+\.\d+\.\d+$") {
            $version = "$version`.0"
        }elseif($version -notmatch "^\d+\.\d+\.\d+\.\d+$") {
            Write-Error "Invalid version '$version', should be in the format '#.#.#' or '#.#.#.#'."
        }
        if($fileVersion -match "^\d+\.\d+\.\d+$") {
            $fileVersion = "$fileVersion`.0"
        }elseif($fileVersion -notmatch "^\d+\.\d+\.\d+\.\d+$") {
            Write-Error "Invalid fileVersion '$fileVersion', should be in the format '#.#.#' or '#.#.#.#'."
        }
        if($infoVersion -notmatch "^\d+\.\d+\.\d+[\+\-]") {
            Write-Error "Invalid fileVersion '$infoVersion', should start with '#.#.#-' or '#.#.#.#+'."
        }

        Write-Host "Normalized Versions:"
        Write-Host "Version      = $version"
        Write-Host "File Version = $fileVersion"
        Write-Host "Info Version = $infoVersion"
        
        $patterns = @(
            '^\s*\[\s*assembly\s*:\s*AssemblyVersion\s*\(',
            '^\s*\[\s*assembly\s*:\s*AssemblyFileVersion\s*\(',
            '^\s*\[\s*assembly\s*:\s*AssemblyInformationalVersion\s*\('
        )

        $vbPatterns = @(
            '^\s*<\s*Assembly\s*:\s*AssemblyVersion\s*\(',
            '^\s*<\s*Assembly\s*:\s*AssemblyFileVersion\s*\(',
            '^\s*<\s*Assembly\s*:\s*AssemblyInformationalVersion\s*\('
        )

        $files = Get-ChildItem -Recurse -Include AssemblyInfo.cs, AssemblyInfo.vb -ErrorAction SilentlyContinue
        foreach ($file in $files) {
            Write-Host "Found AssemblyInfo File`: $file"

            $lines = Get-Content -LiteralPath $file.FullName
            $changed = $false

            for ($i = 0; $i -lt $lines.Length; $i++) {
                $line = $lines[$i]

                if ($file.Extension -eq '.cs') {
                    if ($patterns | Where-Object { $line -match $_ }) {
                        if ($line -notmatch '^\s*//') {
                            $lines[$i] = "// $line"
                            $changed = $true
                        }
                    }
                }
                else {
                    if ($vbPatterns | Where-Object { $line -match $_ }) {
                        if ($line -notmatch "^\s*'") {
                            $lines[$i] = "`' $line"
                            $changed = $true
                        }
                    }
                }
            }

            $lines += "//Injected by Workflow"
            $lines += "[assembly: AssemblyVersion(`"$version`")]"
            $lines += "[assembly: AssemblyFileVersion(`"$fileVersion`")]"
            $lines += "[assembly: AssemblyInformationalVersion(`"$infoVersion`")]"

            if ($changed) {
                Write-Host "Neutralized version attributes in $($file.FullName)"
            }
            Write-Host "New File:"
            for ($i = 0; $i -lt $lines.Length; $i++) {
                $line = $lines[$i]
                Write-Host "$line"
            }
            Set-Content -LiteralPath $file.FullName -Value $lines -Encoding UTF8
        }


    - name: Validate no hard-coded version attributes remain
      if: ${{ inputs.neutralizeAssemblyInfo }} == 'true'
      shell: pwsh
      run: |
        $files = Get-ChildItem -Recurse -Include AssemblyInfo.cs,AssemblyInfo.vb -ErrorAction SilentlyContinue
        if (-not $files) {
            Write-Host "No AssemblyInfo.cs or AssemblyInfo.vb files found. Skipping version attribute validation."
            exit 0
        }

        $hits = Select-String -Path $files `
            -Pattern 'AssemblyVersion\(', 'AssemblyFileVersion\(', 'AssemblyInformationalVersion\(' `
            | Where-Object { $_.Line -notmatch "^\s*(//|'')" }

        if ($hits) {
            Write-Error ("Hard-coded version attributes found:`n" + ($hits | ForEach-Object { "$($_.Path):$($_.LineNumber): $($_.Line)" } | Out-String))
        }

inputs:
  version:
    description: 'Version (e.g., 1.0.0)'
    required: true
  assemblyVersion:
    description: 'Assembly version (e.g., 1.0.0)'
    required: true
  fileVersion:
    description: 'File version (e.g., 1.0.0)'
    required: true
  infoVersion:
    description: 'Informational Version (e.g., 1.0.0-rc+build-main-sha...)'
    required: true
  company:
    description: 'Company Name (e.g., Silver Digits LLC)'
    required: false
  copyright:
    description: 'Copyright text to set in Directory.Build.props'
    required: false
  neutralizeAssemblyInfo:
    description: 'If true, removes existing AssemblyVersion/FileVersion attributes from AssemblyInfo.cs/vb files to avoid conflicts.'
    required: false
    default: 'false'

