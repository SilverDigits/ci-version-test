
name: CI (Windows .NET Framework Unified)

on:
  push:
    branches: [ "main", "staging" ]
  pull_request:
    branches: [ "main", "staging" ]
  workflow_dispatch:
    inputs:
      create_release:
        description: "Create Production Release?"
        type: choice
        options:
          - "no"
          - "yes"
        required: false
        default: "no"

permissions:
  contents: write      # needed to create tags/releases
  packages: write      # needed for GHCR push
  id-token: write      # optional if you use OIDC for cloud deploys
  actions: read

env:
    SLN_PATH: ci-version-test.sln
    ASSEMBLY_COPYRIGHT: "Copyright (c) Silver Digits LLC."
    GHCR_REPO: ghcr.io/silverdigits/ci-version-test

jobs:
  ci:
    name: CI
    runs-on: windows-latest

    outputs:
      should_release: ${{ steps.gates.outputs.should_release }}
      image_version:  ${{ steps.compute.outputs.image_version }}
      image_name:     ${{ steps.compute.outputs.image_name }}
    
    env:
      BUILD_OUT_DIR: ${{ github.workspace }}\build
      PUBLISH_ROOT: ${{ github.workspace }}\publish

    steps:
      # -------------------------------------------
      # Checkout
      # -------------------------------------------
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      # -------------------------------------------
      # Compute Release Gates
      # -------------------------------------------
      - name: Compute release gates
        id: gates
        shell: pwsh
        run: |
          $isPush    = '${{ github.event_name }}' -eq 'push'
          $isMain    = '${{ github.ref }}' -eq 'refs/heads/main'
          $isStaging = '${{ github.ref }}' -eq 'refs/heads/staging'
          $shouldRelease = $isPush -and ($isMain -or $isStaging)

          "is_push=$isPush"             | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "is_main=$isMain"             | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "is_staging=$isStaging"       | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "should_release=$shouldRelease" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      # -------------------------------------------
      # Setup GitVersion 6.4.x setup
      # -------------------------------------------
      - name: Setup GitVersion
        uses: gittools/actions/gitversion/setup@v4.2.0
        with:
          versionSpec: '6.4.x'

      # -------------------------------------------
      # Determine Version
      # -------------------------------------------
      - name: Determine Version
        id: gitversion
        uses: gittools/actions/gitversion/execute@v4.2.0

      - name: Display Versions
        run: |
            Write-Host "semVer: $env:GitVersion_SemVer"
            Write-Host "branchName: $env:GitVersion_BranchName"
            Write-Host "escapedBranchName: $env:GitVersion_EscapedBranchName"
            Write-Host "major: $env:GitVersion_Major"
            Write-Host "minor: $env:GitVersion_Minor"
            Write-Host "patch: $env:GitVersion_Patch"
            Write-Host "preReleaseTag: $env:GitVersion_PreReleaseTag"
            Write-Host "preReleaseTagWithDash: $env:GitVersion_PreReleaseTagWithDash"
            Write-Host "preReleaseLabel: $env:GitVersion_PreReleaseLabel"
            Write-Host "preReleaseNumber: $env:GitVersion_PreReleaseNumber"
            Write-Host "weightedPreReleaseNumber: $env:GitVersion_WeightedPreReleaseNumber"
            Write-Host "buildMetaData: $env:GitVersion_BuildMetaData"
            Write-Host "fullBuildMetaData: $env:GitVersion_FullBuildMetaData"
            Write-Host "majorMinorPatch: $env:GitVersion_MajorMinorPatch"
            Write-Host "assemblySemVer: $env:GitVersion_AssemblySemVer"
            Write-Host "assemblySemFileVer: $env:GitVersion_AssemblySemFileVer"
            Write-Host "fullSemVer: $env:GitVersion_FullSemVer"
            Write-Host "informationalVersion: $env:GitVersion_InformationalVersion"
            Write-Host "sha: $env:GitVersion_Sha"
            Write-Host "shortSha: $env:GitVersion_ShortSha"
            Write-Host "versionSourceSha: $env:GitVersion_VersionSourceSha"
            Write-Host "commitsSinceVersionSource: $env:GitVersion_CommitsSinceVersionSource"
            Write-Host "uncommittedChanges: $env:GitVersion_UncommittedChanges"
            Write-Host "commitDate: $env:GitVersion_CommitDate"


      # -------------------------------------------
      # Create Release Tag (push to staging and main only)
      # -------------------------------------------
      - name: Create Release Tag
        id: tags
        #if: ${{ github.event_name == 'workflow_dispatch' && inputs.create_release == 'yes' }}
        if: steps.gates.outputs.should_release
        run: |
          $tag = "v$env:GitVersion_SemVer"
          Write-Host "Tagging release as $tag"
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git tag $tag
          git push origin $tag

      # -------------------------------------------
      # Re-checkout tag if one was just created
      # -------------------------------------------
      - name: Checkout Tag for Release
        if: steps.gates.outputs.should_release
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: v${{ steps.gitversion.outputs.SemVer }}


      # -------------------------------------------
      # Setup Build Environment
      # -------------------------------------------
      - name: Setup NuGet
        uses: NuGet/setup-nuget@v2

      - name: Set up MSBuild
        uses: microsoft/setup-msbuild@v2

      # - name: Set up NuGet authentication
      #   run: nuget sources Add -Name "rrglobal" -Source "https://nuget.pkg.github.com/rrglobal/index.json" -Username "rollsroycebot" -Password ${{ secrets.ROLLSROYCEBOT_PAT }}

      - name: Restore NuGet packages
        run: nuget restore "$env:SLN_PATH"

      - name: Setup Variables
        shell: pwsh
        run: |
            $year = (Get-Date).Year
            Add-Content -Path $env:GITHUB_ENV -Value "ASSEMBLY_COPYRIGHT=$env:ASSEMBLY_COPYRIGHT $year"
            $shortSha = $env:GITHUB_SHA.Substring(0,7)
            Add-Content -Path $env:GITHUB_ENV -Value "ASSEMBLY_INFO_VERSION=$shortSha"

      - name: Update Directory.Build.props with Version Info
        run: |
            $propsPath = "Directory.Build.props"

            function New-PropsXml{
                $doc = New-Object System.Xml.XmlDocument

                # XML declaration
                $xmlDecl = $doc.CreateXmlDeclaration('1.0','utf-8',$null)
                $doc.AppendChild($xmlDecl) | Out-Null

                # <Project Sdk="Microsoft.NET.Sdk">
                $project = $doc.CreateElement('Project')
                # NOTE: Directory.Build.props typically doesn't need Sdk attr, but it's harmless if present.
                # If you prefer no Sdk attr, comment the next line.
                # $project.SetAttribute('Sdk','Microsoft.NET.Sdk') 
                $doc.AppendChild($project) | Out-Null

                # <PropertyGroup>
                $pg = $doc.CreateElement('PropertyGroup')
                $project.AppendChild($pg) | Out-Null

                return $doc
            }
            [xml]$xml = $null
            if(Test-Path $propsPath) {
                try {
                    $xml = [xml](Get-Content $propsPath)
                }catch{
                    Write-Warning "Existing $propsPath was not valid XML. Recreating."
                    $xml = New-PropsXml
                }
                #Write-Error "Directory.Build.props not found at path: $propsPath"
                #exit 1
            }else{
                Write-Warning "Creating new $propsPath"
                $xml = New-PropsXml
            }

            # Ensure <Project> root exists
            if (-not $xml.Project) {
              $project = $xml.CreateElement('Project')
              $null = $xml.AppendChild($project)
            } else {
              $project = $xml.Project
            }

            # Ensure there is at least one <PropertyGroup>
            $pg = $project.PropertyGroup
            if (-not $pg) {
              $pg = $xml.CreateElement('PropertyGroup')
              $null = $project.AppendChild($pg)
            }

            # Helper: set or create a property in the first PropertyGroup
            function Set-XmlProp([string]$name, [string]$value) {
              if ([string]::IsNullOrWhiteSpace($value)) { return }
              $node = $pg.SelectSingleNode($name)
              if (-not $node) {
                $node = $xml.CreateElement($name)
                $null = $pg.AppendChild($node)
              }
              $node.InnerText = $value
            }

            # Pull values from GitVersion step outputs
            $SemVer               = '${{ steps.gitversion.outputs.semVer }}'
            $AssemblySemVer       = '${{ steps.gitversion.outputs.assemblySemVer }}'
            $FileSemVer           = '${{ steps.gitversion.outputs.assemblySemFileVer }}'  # good for FileVersion
            $InformationalVersion = '${{ steps.gitversion.outputs.informationalVersion }}'

            # Map to MSBuild properties
            Set-XmlProp 'Version'              $SemVer
            Set-XmlProp 'AssemblyVersion'      $AssemblySemVer
            Set-XmlProp 'FileVersion'          $FileSemVer
            Set-XmlProp 'InformationalVersion' $InformationalVersion

            # Save with indentation and UTF-8
            $settings = New-Object System.Xml.XmlWriterSettings
            $settings.Indent = $true
            $settings.IndentChars = "  "
            $settings.NewLineOnAttributes = $false
            $settings.Encoding = New-Object System.Text.UTF8Encoding($false) # no BOM; change to ($true) for BOM

            # $writer = [System.Xml.XmlWriter]::Create((Resolve-Path $propsPath), $settings)
            # $xml.Save($writer)
            # $writer.Flush()
            # $writer.Dispose()

            Write-Warning "Updated $propsPath with version info from GitVersion."
            Write-Warning "{$xml.InnerXml}"
            # msbuild "$env:SLN_PATH" `
            # /t:UpdateVersionInfo `
            # /p:Version=$env:GitVersion_SemVer `
            # /p:AssemblyVersion=$env:GitVersion_AssemblySemVer `
            # /p:FileVersion=$env:GitVersion_AssemblyFileSemVer `
            # /p:InformationalVersion=$env:GitVersion_InformationalVersion




      # - name: Build Solution (Release)
      #   run: |
      #       msbuild "$env:SLN_PATH" `
      #       /t:Build `
      #       /p:Configuration=Release `
      #       /p:Platform="Any CPU" `
      #       /m `
      #       /v:m

      # - name: Publish PRMDS (copy built outputs)
      #   run: |
      #       msbuild "Source\PRMDS.Web\PRMDS.Web.csproj" `
      #       /t:PipelinePreDeployCopyAllFilesToOneFolder `
      #       /p:Configuration=Release `
      #       /p:_PackageTempDir="$env:PUBLISH_ROOT\PRMDS\" `
      #       /p:BuildProjectReferences=false `
      #       /v:m

      # - name: Build (.NET Framework via MSBuild)
      #   run: msbuild "$env:SLN_PATH" `
      #         /t:PipelinePreDeployCopyAllFilesToOneFolder `
      #         /p:Configuration=Release `
      #         /p:Version=$env:GitVersion_SemVer `
      #         /p:AssemblyVersion=$env:GitVersion_AssemblySemVer `
      #         /p:FileVersion=$env:GitVersion_AssemblyFileSemVer `
      #         /p:InformationalVersion=$env:GitVersion_InformationalVersion

      # -------------------------------------------
      # Neutralize AssemblyInfo version attributes
      # -------------------------------------------
      - name: Neutralize AssemblyInfo version attributes
        shell: pwsh
        run: |
            $patterns = @(
              '^\s*\[\s*assembly\s*:\s*AssemblyVersion\s*\(',
              '^\s*\[\s*assembly\s*:\s*AssemblyFileVersion\s*\(',
              '^\s*\[\s*assembly\s*:\s*AssemblyInformationalVersion\s*\('
            )

            $vbPatterns = @(
              '^\s*<\s*Assembly\s*:\s*AssemblyVersion\s*\(',
              '^\s*<\s*Assembly\s*:\s*AssemblyFileVersion\s*\(',
              '^\s*<\s*Assembly\s*:\s*AssemblyInformationalVersion\s*\('
            )

            $files = Get-ChildItem -Recurse -Include AssemblyInfo.cs, AssemblyInfo.vb -ErrorAction SilentlyContinue

            foreach ($file in $files) {
              $lines = Get-Content -LiteralPath $file.FullName
              $changed = $false

              for ($i = 0; $i -lt $lines.Length; $i++) {
                $line = $lines[$i]

                if ($file.Extension -eq '.cs') {
                  if ($patterns | Where-Object { $line -match $_ }) {
                    if ($line -notmatch '^\s*//') {
                      $lines[$i] = "// $line"
                      $changed = $true
                    }
                  }
                }
                else {
                  if ($vbPatterns | Where-Object { $line -match $_ }) {
                    if ($line -notmatch "^\s*'") {
                      $lines[$i] = "`' $line"
                      $changed = $true
                    }
                  }
                }
              }

              if ($changed) {
                Set-Content -LiteralPath $file.FullName -Value $lines -Encoding UTF8
                Write-Host "Neutralized version attributes in $($file.FullName)"
              }
            }

      - name: Validate no hard-coded version attributes remain
        shell: pwsh
        run: |
            $files = Get-ChildItem -Recurse -Include AssemblyInfo.cs,AssemblyInfo.vb -ErrorAction SilentlyContinue
            if (-not $files) {
                Write-Host "No AssemblyInfo.cs or AssemblyInfo.vb files found. Skipping version attribute validation."
                exit 0
            }

            $hits = Select-String -Path $files `
                -Pattern 'AssemblyVersion\(', 'AssemblyFileVersion\(', 'AssemblyInformationalVersion\(' `
                | Where-Object { $_.Line -notmatch "^\s*(//|'')" }

            if ($hits) {
                Write-Error ("Hard-coded version attributes found:`n" + ($hits | ForEach-Object { "$($_.Path):$($_.LineNumber): $($_.Line)" } | Out-String))
            }

      # -------------------------------------------
      # Neutralize AssemblyInfo version attributes
      # -------------------------------------------
      - name: Compute Image Name and Version
        id: compute
        #if: steps.gates.outputs.should_release
        run: |
            $imageName = "my-image"
            $imageVersion = $env:GitVersion_SemVer         
            "image_version=$imageVersion" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            "image_name=$imageName"       | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            Write-Host "image_name = $imageName"
            Write-Host "image_version = $imageVersion"

  package:
    name: Build Deployment Package(s)
    runs-on: ubuntu-latest
    needs: ci
    #if: needs.ci.ouputs.should_release == 'true'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Packaging Options
        run: |
          echo "should_release = ${{ needs.ci.outputs.should_release }}"
          echo "image_version  = ${{ needs.ci.outputs.image_version }}"
          echo "image_name     = ${{ needs.ci.outputs.image_name }}"

      - name: Packaging Options
        run: |
          echo "should_release = ${{ needs.ci.outputs.should_release }}"
          echo "image_version  = ${{ needs.ci.outputs.image_version }}"
          echo "image_name     = ${{ needs.ci.outputs.image_name }}"

